## 题目：零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的**最少**的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。

```
示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

### 问题思路

首先，这个问题时动态规划问题，因为它具有**最优子结构**。要符合最优子结构，**子问题之间必须相互独立**。

何谓子问题相互独立？在该问题中，比如我们想求 `amount = 11` 时的最少硬币数（原问题），如果我们知道凑出 `amount = 10` 的最少硬币数（子问题），只需要再把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互限制，是互相独立的。

既然已经确认是个动态规划问题，那么列出正确的状态转移方程就是重中之重。

1. **确定base case。**当金额amount为0的时候，所需的最少硬币个数就为0。不要任何硬币就能凑出总金额。
2. **确定状态，也就是原问题和子问题中会变化的变量。**由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。
3. **确定选择，也就是导致状态发生变化的行为。**目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。
4. **明确dp函数/数组的定义。**我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 `dp` 函数：

`dp(n)` 的定义：输入一个目标金额 `n`，返回凑出目标金额 `n` 的最少硬币数量。

### 解法一：暴力递归

```javascript
var coinChange = function(coins, amount) {
    return dp(coins, amount)
};
function dp(coins, amount) {
    if (amount === 0) {
        return 0
    }
    if (amount < 0) {
        return -1
    }
    let res = Number.MAX_SAFE_INTEGER;
    for (let coin of coins) {
        const subProblem = dp(coins, amount - coin)
        if (subProblem === -1) continue
        res = Math.min(res, subProblem + 1)
    }
    return res != Number.MAX_SAFE_INTEGER ? res : -1
}
```

### 解法二：带备忘录的递归

```javascript
const coinChange = function(coins, amount) {
    let memo = []
    function dp(amount) {
        if (memo[amount]) {
            return memo[amount]
        }
        if (amount === 0) {
            return 0
        }
        if (amount < 0) {
            return -1
        }
        let res = Infinity
        for (let coin of coins) {
            const subProblem = dp(amount - coin)
            if (subProblem === -1) continue
            res = Math.min(res, subProblem + 1)
        }
        memo[amount] = res === Infinity ? -1 : res
        // memo[amount] = res
        return memo[amount]
    }
    return dp(amount)
}
```

