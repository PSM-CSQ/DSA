## 斐波那契数

### 题目：

**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给你 n ，请计算F(n)。

### 解法一：暴力递归

```javascript
var fib = function(n) {
    if (n === 0) return 0
    if (n == 1 || n == 2) {
        return 1
    }
    return fib(n - 1) + fib(n - 2)
}
```

遇到递归问题，最好画出递归树，有利于分析算法的复杂度，找到算法低效的原因。

![img](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/1.jpg)

**递归算法的时间复杂度 = 子问题个数（即递归树中节点的总数。） ✖ 解决一个子问题所需的时间**

该解决方法中，子问题个数为O(2^n)。因为没有循环，只有f(n - 1) + f (n - 2) 一个加法操作，时间为O(1)。所以这个这个解法的时间复杂度为O(2^n)。

该算法低效原因：存在大量重复计算。比如在递归树中，不难发现，f(18) 被计算了两次，而且还不只 f(18) 这个节点被重复计算。

也就是存在**重叠子问题**。

### 解法二：带备忘录的递归解法

既然存在重复计算，那么我们可以创建一个“备忘录”，每次计算出某个子问题的结果后，先记录到备忘录上再返回。每次遇到子问题，先去“备忘录”查询该子问题是否存在，如果存在，就把之前计算的结果直接拿出来，不需要再次去计算。

一般使用**数组**充当“备忘录”，也可以使用**哈希表**（字典）。

```javascript
// 带“备忘录”的递归
const memo = []
const fib = function(n) {
    if (n === 0) return 0
    if (n === 1 || n === 2) {
        return 1
    }
    if (memo[n]) {
        return memo[n] 
    }
    const result = fib(n - 1, memo) + fib(n - 2, memo)
    memo[n] = result
    return result
}
```

如今的递归树如下图所示，把一颗存在冗余的递归树通过“剪枝”，改造成一幅不存在冗余的递归树。减少子问题的个数：

![img](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/2.jpg)

本算法的时间复杂度：O(n)。因为子问题个数为O(n)，解决一个子问题的时间仍为O(1)。

至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 `f(20)`，向下逐渐分解规模，直到 `f(1)` 和 `f(2)` 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 `f(1)` 和 `f(2)` 开始往上推，直到推到我们想要的答案 `f(20)`，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

### 解法三：dp数组的迭代解法

将一种解法的“备忘录”独立出来成为一张表（DP Table）。在这张表上完成自底向上的推算。

```javascript
// dp数组的迭代解法
function fib(n) {
    dp = []
    dp[0] = 0
    dp[1] = 1
    dp[2] = 1
    for (let i = 3; i <= n; i ++) {
        dp[i] = dp[i - 1] + dp[i -2]
    }
    return dp[n]
}
```

![img](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/4.jpg)

实际上，这个 DP table 就是解法二「剪枝」后的结果，只是反过来算而已。所以这两种解法效率基本相同。

上面的几种解法中的所有操作，例如 `return f(n - 1) + f(n - 2)`，`dp[i] = dp[i - 1] + dp[i - 2]`，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。

**动态规划问题最困难的就是写出这个暴力解，即状态转移方程**。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。

### 解法四：解法三再次优化

利用(状态压缩技巧)，其实状态只跟前一个数和当前数有关，不需要像第三种解法那样用一个数组进行存储，只需用两个值存储即可，把空间复杂度将为O(1)

```javascript
const fib = function(n) {
    if (n === 0) {
        return 0;
    }
    if (n === 1 || n === 2) {
        return 1;
    }
    let prev = 1
    let curr = 1
    for (let i = 3; i <= n; i++) {
        const sum = prev + curr
        prev = curr
        curr = sum
    }
    return curr
}
```

斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。